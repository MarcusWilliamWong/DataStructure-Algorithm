# 二叉树（Binary Tree）

## 二叉树相关基础概念

满二叉树：叶子节点都存在的二叉树。节点数 2^k^-1，k为树的深度，根节点深度为1

==完全二叉树==：除了底层外，都是满的，而且底层叶子节点是从左到右连续的。因此满二叉树也是完全二叉树的一种。

应用实例：C++中的优先队列本质就是一个大顶堆或者小顶堆实现，堆实际上就是完全二叉树。

二叉搜索树：搜索一个节点的时间复杂度为logn

平衡二叉搜索树：左子树和右子树的高度的绝对值不能超过一。C++中map，set，multimap，multiset的底层实现都是平衡二叉树。因此意味着map，multimap，set，multiset的键值排序是有序的，而unordered_map和unordered_set不是二叉平衡搜索树，而是哈希表实现。



## 二叉树，B树，B+树的关系==（待更新）==



## 二叉树的存储方式

### 链式存储

遍历方式：前序中序后序（指的是节点与其左右孩子的相对顺序），这三种都是深度优先搜索；广度优先搜索，常见的是二叉树层序遍历。

递归法和迭代法都可以遍历二叉树

层序遍历可以利用队列进行二叉树的遍历，可以说层序遍历就是迭代法，使用队列，因为有先进先出的需求



### 线性存储

给一个节点的角标，计算左右子节点的位置，2\*i +1（左孩子节点角标），2\*i +2（右孩子节点角标）

## 二叉树的结构体定义

```
struct TreeNode {
	int val;
	TreeNode* left;
	TreeNode* right;
};

TreeNode(int val): val(val), left(numptr), right(nullptr) {
}
```



## 二叉树的题目确定遍历方式非常重要

## 二叉树的遍历之递归法（前中后序）

写递归的三部曲：（递归的底层机制是栈）

- 确定递归函数的参数和返回值
- 确定终止条件
- 确定单层递归的逻辑



### LeetCode 144. 前序遍历二叉树

```cpp
void traversalTree(TreeNode* current, vector<int>& result) { // --》每次递归都要传入将要遍历的节点指针，然后还需要将遍历结果放在vector中保存，其他也不需要处理什么数据，所以不需要返回值和更多的其他参数
  if (current == nullptr) { // 终止条件：当前节点为空，开始返回
    return;
  }
  // 当前节点为中，根据递归遍历顺序而定一下三行的代码顺序
  result.push_back(current->val);
  // 开始编写单层递归的逻辑
  traversal(current->left); // 开始遍历当前节点的左子树
  traversal(current->right); // 开始遍历当前节点的右子树
}
```

### LeetCode 145. 中序遍历二叉树

### LeetCode 94. 后序遍历二叉树

```cpp
// 中序的遍历逻辑顺序：左中右
traversal(current->left);
result.push_back(current->val);
traversal(current->right);

// 后序遍历的逻辑顺序：左右中
traversal(current->left);
traversal(current->right);
result.push_back(current->val);
```

### LeetCode 101. 对称二叉树



### LeetCode 226. 翻转二叉树

**后序遍历**，可以**收集左右孩子的信息**返回给上一个节点。



## 二叉树的遍历之迭代法==（待更新）==

理论讲解：**递归的本质就是栈实现的，而迭代法相当于模拟计算机栈的操作**。使用**栈的数据结构**处理二叉树得当前遍历节点 ，以前序为例，最终得到的遍历顺序应该为中左右，所以先将当前便利的根节点放入栈中，再弹出，再处理当前根节点的左右孩子，由于是先进后出，而遍历顺序是中左右，所以应该先将右孩子压入栈中，再将左孩子压入栈中；在下一个迭代中，弹出栈顶元素，按照以上处理方法，依旧先将其右孩子压入栈中，再将左孩子压入栈中。





## 二叉树的层序遍历（广度优先遍历）

层序遍历，即一层一层地遍历二叉树节点，关键在于及时保存当前遍历节点的子节点。由于队列特点：先进先出。因此，可以借助队列保存下一层需要遍历的节点，由于当前层节点和下一层节点可能同时存在于队列中，所以需要一个计数器，记录当前层节点剩余数量。那么**遍历结束条件**就是**队列中没有任何节点**可以用于遍历。另外提一下，图论中的广度优先搜索也是依赖队列而实现的。

### LeetCode 102. 二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ret;
        if (!root) return ret;
        queue<TreeNode*> que;
        que.push(root);
        int size = que.size();
        vector<int> temp;
      	// 判断遍历结束条件
        while (!que.empty()) {
        		// 输出当前遍历节点的值
            temp.push_back(que.front()->val);
          	// 添加当前遍历节点的子节点
            if (que.front()->left)
                que.push(que.front()->left);
            if (que.front()->right)
                que.push(que.front()->right);
            que.pop();
          	// 记录当前层节点数
            --size;
          	// 如果当前层节点均被遍历完，那么更新计数器的数量与下一层节点数保持一致
            if (!size) {
                size = que.size();
              	// 注意vector的push_back()时深拷贝，即添加副本，所以可以一直使用temp作为保存当前层的节点值
                ret.push_back(temp);
              	// 每一层遍历结束后清空temp，为下一层遍历做准备
                temp.clear();
            }
        }

        return ret;
    }
};
```



### LeetCode 102. 二叉树的层序遍历



## 二叉排序树

根据关键字序列(30,40,20,60,50,10)，构造对应的二叉树。



二叉排序树查找成功的平均查找长度为：∑（本层高度\*本层元素个数）/节点总数=（1\*1+2\*2+3\*3+3\*4）/9

查找不成功的平均查找长度：∑（本层高度\*本层补上的叶子个数）/补上的叶子总数=（2\*1+3\*3+4\*6）/10

参考：[1二叉树、二叉查找树、二叉排序树、二叉平衡树的区别](https://www.zhihu.com/question/20927368)看到这里了，英雄哪里出来

https://www.zhihu.com/question/20927368

# 树转换为二叉树

对于普通树转二叉树，要记住6个字口诀：左儿子，右兄弟

# 树的深度与高度

## 不同的平衡二叉查找树

## 红黑树

https://blog.csdn.net/cy973071263/article/details/122543826

首先，红黑树是一个二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）。

- 节点是红色或黑色
- 根是黑色
- 叶子节点（外部节点，空节点）都是黑色，这里的叶子节点指的是最底层的空节点（外部节点），下图中的那些null节点才是叶子节点，null节点的父节点在红黑树里不将其看作叶子节点
- 红色节点的子节点都是黑色
- 红色节点的父节点都是黑色
- 从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点
- 从任一节点到叶子节点的所有路径都包含相同数目的黑色节点

### AVL树

### 树堆
