# 二叉树（Binary Tree）

## 二叉树基础概念

满二叉树：叶子节点都存在的二叉树。节点数 2^k^-1，k为树的深度，根节点深度为1

==完全二叉树==：除了底层外，都是满的，而且底层叶子节点是从左到右连续的。因此满二叉树也是完全二叉树的一种。

应用实例：C++中的优先队列本质就是一个大顶堆或者小顶堆实现，堆实际上就是完全二叉树。

二叉搜索树：搜索一个节点的时间复杂度为logn

平衡二叉搜索树：左子树和右子树的高度的绝对值不能超过一。C++中map，set，multimap，multiset的底层实现都是平衡二叉树。因此意味着map，multimap，set，multiset的键值排序是有序的，而unordered_map和unordered_set不是二叉平衡搜索树，而是哈希表实现。



## 二叉树，B树，B+树的关系==（待更新）==



## 二叉树的存储方式

### 链式存储

遍历方式：前序中序后序（指的是节点与其左右孩子的相对顺序），这三种都是深度优先搜索；广度优先搜索，常见的是二叉树层序遍历。

递归法和迭代法都可以遍历二叉树

层序遍历可以利用队列进行二叉树的遍历，可以说层序遍历就是迭代法，使用队列，因为有先进先出的需求



### 线性存储

给一个节点的角标，计算左右子节点的位置，2\*i +1（左孩子节点角标），2\*i +2（右孩子节点角标）

## 二叉树的定义

```
struct TreeNode {
	int val;
	TreeNode* left;
	TreeNode* right;
};

TreeNode(int val): val(val), left(numptr), right(nullptr) {
}
```



## 二叉树的遍历之递归法

写递归的三部曲：（递归的底层机制是栈）

- 确定递归函数的参数和返回值
- 确定终止条件
- 确定单层递归的逻辑

## LeetCode题目

### LeetCode 144. 前序遍历二叉树

```cpp
void traversalTree(TreeNode* current, vector<int>& result) { // --》每次递归都要传入将要遍历的节点指针，然后还需要将遍历结果放在vector中保存，其他也不需要处理什么数据，所以不需要返回值和更多的其他参数
  if (current == nullptr) { // 终止条件：当前节点为空，开始返回
    return;
  }
  // 当前节点为中，根据递归遍历顺序而定一下三行的代码顺序
  result.push_back(current->val);
  // 开始编写单层递归的逻辑
  traversal(current->left); // 开始遍历当前节点的左子树
  traversal(current->right); // 开始遍历当前节点的右子树
}
```



```cpp
// 中序的遍历逻辑顺序：左中右
traversal(current->left);
result.push_back(current->val);
traversal(current->right);

// 后序遍历的逻辑顺序：左右中
traversal(current->left);
traversal(current->right);
result.push_back(current->val);
```

### LeetCode 145. 中序遍历二叉树

### LeetCode 94. 后序遍历二叉树



## 二叉树的遍历之迭代法

理论讲解：**递归的本质就是栈实现的，而迭代法相当于模拟计算机栈的操作**。使用**栈的数据结构**处理二叉树得当前遍历节点 ，以前序为例，最终得到的遍历顺序应该为中左右，所以先将当前便利的根节点放入栈中，再弹出，再处理当前根节点的左右孩子，由于是先进后出，而遍历顺序是中左右，所以应该先将右孩子压入栈中，再将左孩子压入栈中；在下一个迭代中，弹出栈顶元素，按照以上处理方法，依旧先将其右孩子压入栈中，再将左孩子压入栈中。



## 二叉树的层序遍历（广度优先遍历）

借助队列保存每一层遍历过的元素，队列特点：先进先出。另外图论中的广度优先搜索也是依赖队列而实现的。



## 二叉排序树

根据关键字序列(30,40,20,60,50,10)，构造对应的二叉树。



二叉排序树查找成功的平均查找长度为：∑（本层高度\*本层元素个数）/节点总数=（1\*1+2\*2+3\*3+3\*4）/9

查找不成功的平均查找长度：∑（本层高度\*本层补上的叶子个数）/补上的叶子总数=（2\*1+3\*3+4\*6）/10

## 红黑树

https://blog.csdn.net/cy973071263/article/details/122543826

首先，红黑树是一个二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）。

- 节点是红色或黑色
- 根是黑色
- 叶子节点（外部节点，空节点）都是黑色，这里的叶子节点指的是最底层的空节点（外部节点），下图中的那些null节点才是叶子节点，null节点的父节点在红黑树里不将其看作叶子节点
- 红色节点的子节点都是黑色
- 红色节点的父节点都是黑色
- 从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点
- 从任一节点到叶子节点的所有路径都包含相同数目的黑色节点
